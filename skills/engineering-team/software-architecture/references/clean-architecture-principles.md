# Clean Architecture Principles

A distillation of Robert C. Martin's Clean Architecture, Alistair Cockburn's Hexagonal Architecture (Ports and Adapters), Jeffrey Palermo's Onion Architecture, and related patterns. These architectures share the same objective: **separation of concerns through layers with an inward-pointing dependency rule**.

## The Dependency Rule

Source code dependencies can only point **inwards**. Nothing in an inner circle can know anything about something in an outer circle. No name declared in an outer circle may be mentioned by code in an inner circle. Data formats generated by an outer circle must not be used by an inner circle.

This single rule makes the architecture work.

## Layers (Inside Out)

### 1. Entities (Domain Models)

Enterprise-wide business rules. Objects with methods, or data structures with functions. These are the least likely to change when something external changes. No operational change to any particular application should affect this layer.

- Pure data and business rules
- No framework dependencies
- No I/O, no side effects
- Shared across use cases

### 2. Use Cases (Domain Services)

Application-specific business rules. Orchestrate the flow of data to and from entities. Direct entities to use their business rules to achieve the goals of the use case.

- One class or function per use case
- Depends on entities and port interfaces
- Contains application logic (not infrastructure logic)
- Changes when application behavior changes

### 3. Interface Adapters (Ports and Adapters)

Convert data between the format most convenient for use cases and the format most convenient for external agencies (database, web, external APIs).

- **Ports**: Interfaces that define what the domain needs (inbound) or provides (outbound)
- **Adapters**: Concrete implementations that fulfill port contracts
- Controllers, presenters, gateways all live here
- All SQL, HTTP client code, serialization lives here

### 4. Frameworks and Drivers (Infrastructure / Runtime)

The outermost layer. Frameworks, tools, database engines, web servers. Glue code that communicates to the next circle inward.

- Entry points (HTTP handlers, CLI, Lambda handlers)
- Configuration and dependency wiring (factories)
- Framework-specific code
- "The web is a detail. The database is a detail."

## Properties of Conforming Systems

Systems that follow these rules are:

1. **Independent of frameworks** — frameworks are tools, not constraints
2. **Testable** — business rules tested without UI, database, or external services
3. **Independent of UI** — swap web for console without changing business rules
4. **Independent of database** — swap SQL for NoSQL without changing business rules
5. **Independent of external agencies** — business rules know nothing about the outside world

## Crossing Boundaries

The flow of control often opposes the direction of source code dependencies. Resolve this with **Dependency Inversion**: use cases define output port interfaces (inner circle), and presenters/adapters in the outer circle implement them. Dynamic polymorphism creates source code dependencies that oppose control flow, conforming to the Dependency Rule regardless of control direction.

## Data Across Boundaries

Pass isolated, simple data structures across boundaries. Never pass entities or database rows outward. Never pass framework-specific formats inward. Data crossing a boundary should always be in the form most convenient for the **inner** circle.

## How Many Layers?

Four is not a fixed number. Add layers as needed. The Dependency Rule always applies: source code dependencies always point inwards. As you move inward, abstraction increases. The outermost circle is low-level concrete detail; the innermost is the most general.

## Sources

- Robert C. Martin, "The Clean Architecture" (2012) — https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html
- Alistair Cockburn, "Hexagonal Architecture" (Ports and Adapters)
- Jeffrey Palermo, "Onion Architecture"
- Steve Freeman and Nat Pryce, "Growing Object-Oriented Software, Guided by Tests"
- Ivar Jacobson, "Object Oriented Software Engineering: A Use-Case Driven Approach" (BCE)
